<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" />
<title>RectBlox</title>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6244767628762401"
     crossorigin="anonymous"></script>
<style>
  html, body { 
    margin: 0; 
    padding: 0; 
    background: linear-gradient(135deg, #f7e7ce 0%, #e8c5a0 50%, #f2d7b6 100%);
    min-height: 100vh;
    color: #6b4e3d;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    overflow: hidden; /* Hide scrollbars completely */
    width: 100vw;
    height: 100vh;
  }
  
  .container { 
    max-width: min(90vw, 600px);
    margin: 0 auto;
    padding: 20px;
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    position: relative;
  }
  
  .heading { 
    text-align: center; 
    margin-bottom: 2rem;
  }
  
  .heading h1 { 
    font-size: clamp(2rem, 4vw, 3rem);
    margin: 0;
    font-weight: 700;
    background: linear-gradient(45deg, #d4a574, #c8956d, #b8926f);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 0 4px 6px rgba(212, 165, 116, 0.3);
    letter-spacing: -0.5px;
  }
  
  .game-wrapper {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    border-radius: 24px;
    padding: 2rem;
    box-shadow: 
      0 8px 32px rgba(212, 165, 116, 0.3),
      0 2px 8px rgba(200, 149, 109, 0.2),
      inset 0 1px 0 rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(212, 165, 116, 0.2);
    width: 100%;
    max-width: 500px;
  }
  
  .score-panel { 
    display: flex; 
    justify-content: center;
    align-items: center; 
    margin-bottom: 1.5rem; 
    gap: 1rem;
    flex-wrap: wrap;
  }
  
  .level-info {
    background: linear-gradient(135deg, #b8926f 0%, #a67c52 100%);
    backdrop-filter: blur(10px);
    color: #ffffff; 
    padding: 0.8rem 1.2rem; 
    border-radius: 14px; 
    font-size: 0.9rem;
    font-weight: 600;
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 
      0 4px 15px rgba(184, 146, 111, 0.4),
      0 2px 6px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.3);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  }
  
  .score-box { 
    background: linear-gradient(135deg, #d4a574 0%, #c8956d 100%);
    backdrop-filter: blur(10px);
    color: #ffffff; 
    padding: 1rem 1.5rem; 
    border-radius: 16px; 
    font-size: 1.1rem;
    font-weight: 700;
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 
      0 6px 20px rgba(212, 165, 116, 0.4),
      0 2px 8px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.3);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    transform: scale(1.05);
  }
  
  .secondary-button { 
    background: rgba(212, 165, 116, 0.2);
    backdrop-filter: blur(10px);
    color: #6b4e3d; 
    border: none; 
    padding: 0.6rem 1rem; 
    border-radius: 10px; 
    font-size: 0.8rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(212, 165, 116, 0.2);
    border: 1px solid rgba(212, 165, 116, 0.3);
    opacity: 0.8;
  }
  
  .secondary-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(212, 165, 116, 0.3);
    opacity: 1;
  }
  
  .secondary-button:active {
    transform: translateY(0px);
    box-shadow: 0 1px 4px rgba(212, 165, 116, 0.2);
  }
  
  button { 
    background: linear-gradient(135deg, #d4a574 0%, #c8956d 100%);
    color: #6b4e3d; 
    border: none; 
    padding: 0.75rem 1.25rem; 
    border-radius: 12px; 
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(212, 165, 116, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    backdrop-filter: blur(10px);
  }
  
  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(212, 165, 116, 0.4);
    background: linear-gradient(135deg, #c8956d 0%, #d4a574 100%);
  }
  
  button:active {
    transform: translateY(0px);
    box-shadow: 0 2px 10px rgba(212, 165, 116, 0.3);
  }
  .game-container { 
    position: relative; 
    width: 100%;
    aspect-ratio: 1;
    max-width: 450px;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    border-radius: 20px; 
    padding: 1rem; 
    box-sizing: border-box;
    box-shadow: 
      inset 0 1px 0 rgba(255, 255, 255, 0.2),
      0 4px 15px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.15);
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    touch-action: none; 
  }
  
  .grid-container { position:absolute; z-index:1; top:1rem; left:1rem; right:1rem; bottom:1rem; display:none; }
  .grid-cell { display:none; }
  .tile-container { position:absolute; z-index:2; top:1rem; left:1rem; right:1rem; bottom:1rem; }
  
  .overlay { 
    position:absolute; 
    top:0; 
    left:0; 
    width:100%; 
    height:100%; 
    background: rgba(0,0,0,0.8);
    backdrop-filter: blur(10px);
    display:none; 
    flex-direction:column; 
    align-items:center; 
    justify-content:center; 
    z-index:10;
    border-radius: 20px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }
  
  .overlay.show { display:flex; }
  
  .overlay .text { 
    color: #fff; 
    font-size: clamp(1.5rem, 4vw, 2.5rem);
    text-align: center; 
    margin-bottom: 1.5rem;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  
  .score-summary {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 1.5rem;
    margin: 1rem 0;
    color: #6b4e3d;
    font-size: 1rem;
    line-height: 1.6;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    max-width: 300px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .score-summary:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
  }
  
  .score-item {
    display: flex;
    justify-content: space-between;
    margin: 0.5rem 0;
    padding: 0.3rem 0;
    border-bottom: 1px solid rgba(107, 78, 61, 0.2);
  }
  
  .score-item:last-child {
    border-bottom: none;
    font-weight: bold;
    font-size: 1.1rem;
    color: #d4a574;
  }
  
  .overlay button { 
    background: linear-gradient(135deg, #d4a574 0%, #c8956d 100%);
    color: #6b4e3d;
    position: relative;
    z-index: 11;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    font-size: 1rem;
    padding: 1rem 2rem;
    border-radius: 16px;
    box-shadow: 0 4px 15px rgba(212, 165, 116, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.5);
    backdrop-filter: blur(10px);
    margin: 0.5rem;
  }
  
  .instructions {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 1rem;
    margin: 0.5rem 0;
    color: #6b4e3d;
    font-size: 0.85rem;
    line-height: 1.4;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    max-width: 250px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .instructions:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  }
  .tile { 
    position: absolute; 
    width: 90px; 
    height: 90px; 
    border-radius: 12px; 
    transition: all 150ms cubic-bezier(0.25, 0.46, 0.45, 0.94);
    text-align: center;
    font-weight: 700;
    font-size: 55px;
    line-height: 90px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    box-shadow: 
      0 4px 8px rgba(0, 0, 0, 0.12),
      0 2px 4px rgba(0, 0, 0, 0.08);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .tile:hover {
    filter: brightness(1.05);
    transform: translateZ(0) scale(1.02);
    box-shadow: 
      0 6px 12px rgba(0, 0, 0, 0.15),
      0 3px 6px rgba(0, 0, 0, 0.1);
  }
  .tile-new { 
    opacity: 0; 
    transform: scale(0); 
    animation: tile-appear 300ms ease-out forwards; 
  }
  .tile-remove { 
    animation: tile-explode 400ms ease-in forwards; 
    z-index: 10;
  }
  
  /* Appearance animation */
  @keyframes tile-appear {
    0% { opacity: 0; transform: scale(0) rotate(180deg); }
    50% { opacity: 0.8; transform: scale(1.1) rotate(90deg); }
    100% { opacity: 1; transform: scale(1) rotate(0deg); }
  }
  
  /* Explosion removal animation */
  @keyframes tile-explode {
    0% { 
      opacity: 1; 
      filter: brightness(1); 
    }
    25% { 
      opacity: 0.9; 
      filter: brightness(1.5) saturate(1.5); 
      box-shadow: 0 0 40px 15px currentColor; 
    }
    50% { 
      opacity: 0.7; 
      filter: brightness(2) saturate(2); 
      box-shadow: 0 0 60px 20px currentColor; 
    }
    75% { 
      opacity: 0.4; 
      filter: brightness(3) blur(2px); 
      box-shadow: 0 0 80px 25px currentColor; 
    }
    100% { 
      opacity: 0; 
      filter: brightness(0) blur(5px); 
      box-shadow: 0 0 100px 30px transparent; 
    }
  }
  
  /* Simplified pulse effect */
  @keyframes tile-pulse {
    0% { 
      opacity: 1;
      transform: scale(1);
      filter: brightness(1);
    }
    50% { 
      opacity: 0.3;
      transform: scale(1.1);
      filter: brightness(1.5);
    }
    100% { 
      opacity: 0;
      transform: scale(1);
      filter: brightness(1);
    }
  }
  
  /* Simplified particle effects */
  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 15;
    animation: particle-burst 400ms ease-out forwards;
  }
  
  @keyframes particle-burst {
    0% { 
      opacity: 1; 
      transform: scale(1); 
    }
    100% { 
      opacity: 0; 
      transform: scale(0) translate(var(--dx, 0), var(--dy, 0)); 
    }
  }
  
  /* Simplified ripple effect */
  @keyframes ripple-effect {
    0% { 
      opacity: 0.6; 
      transform: scale(0.8); 
    }
    100% { 
      opacity: 0; 
      transform: scale(2); 
    }
  }
  
  /* Combo effects */
  @keyframes combo-fade {
    0% { 
      opacity: 0; 
      transform: translate(-50%, -50%) scale(0.8); 
    }
    20% { 
      opacity: 1; 
      transform: translate(-50%, -50%) scale(1.1); 
    }
    80% { 
      opacity: 1; 
      transform: translate(-50%, -50%) scale(1); 
    }
    100% { 
      opacity: 0; 
      transform: translate(-50%, -60%) scale(0.9); 
    }
  }
  
  /* Pulse animation for instructions */
  @keyframes pulse {
    0% { opacity: 0.7; }
    50% { opacity: 1; }
    100% { opacity: 0.7; }
  }
  /* Color styles - warm milk tea colors */
  .tile-red   { 
    background: linear-gradient(135deg, #e8a87c 0%, #d27d2d 100%);
    color: #ffffff; 
    box-shadow: 
      0 4px 15px rgba(232, 168, 124, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  .tile-green { 
    background: linear-gradient(135deg, #a8b47f 0%, #8e9c6e 100%);
    color: #ffffff; 
    box-shadow: 
      0 4px 15px rgba(168, 180, 127, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  .tile-blue  { 
    background: linear-gradient(135deg, #9eb3c2 0%, #7a9bb8 100%);
    color: #ffffff; 
    box-shadow: 
      0 4px 15px rgba(158, 179, 194, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  /* 4th color: warm purple */
  .tile-purple { 
    background: linear-gradient(135deg, #c8a2d8 0%, #b19bc8 100%);
    color: #ffffff; 
    box-shadow: 
      0 4px 15px rgba(200, 162, 216, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  /* 5th color: bright yellow */
  .tile-orange { 
    background: linear-gradient(135deg, #f9c74f 0%, #f8961e 100%);
    color: #ffffff; 
    box-shadow: 
      0 4px 15px rgba(249, 199, 79, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  /* 6th color: soft pink */
  .tile-pink { 
    background: linear-gradient(135deg, #e8a2b8 0%, #d48ba8 100%);
    color: #ffffff; 
    box-shadow: 
      0 4px 15px rgba(232, 162, 184, 0.3),
      0 2px 4px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  /* Responsive design */
  @media screen and (max-width: 768px) {
    .container { 
      padding: 1rem;
      height: 100vh;
      box-sizing: border-box;
    }
    
    .game-wrapper {
      padding: 1.5rem;
      border-radius: 20px;
      box-sizing: border-box;
    }
    
    .heading h1 { 
      font-size: clamp(1.8rem, 6vw, 2.5rem);
    }
    
    .score-panel { 
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    
    .level-info {
      font-size: 0.8rem;
      padding: 0.7rem 1rem;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .score-box, .secondary-button { 
      font-size: 0.75rem; 
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .score-box {
      padding: 0.9rem 1.3rem;
      font-size: 1rem;
    }
    
    .secondary-button {
      padding: 0.5rem 0.8rem;
      font-size: 0.75rem;
    }
    
    button, .secondary-button {
      min-height: 44px;
      cursor: pointer;
    }
    
    .game-container { 
      max-width: 380px;
      padding: 0.75rem;
    }
    
    .tile-container, .grid-container { 
      top: 0.75rem; 
      left: 0.75rem; 
      right: 0.75rem; 
      bottom: 0.75rem;
    }
    
    .tile { 
      border-radius: 8px;
      font-size: clamp(1rem, 5vw, 1.5rem);
    }
    
    .overlay button {
      font-size: 0.9rem;
      padding: 0.9rem 1.8rem;
      min-height: 50px;
      margin-top: 0.5rem;
    }
    
    .overlay .text {
      font-size: clamp(1.2rem, 5vw, 2rem);
    }
  }
  
  /* Large screen optimization */
  @media screen and (min-width: 1200px) {
    .container {
      max-width: 700px;
      box-sizing: border-box;
    }
    
    .game-wrapper {
      max-width: 600px;
      padding: 3rem;
      box-sizing: border-box;
    }
    
    .game-container {
      max-width: 550px;
    }
  }
  
  /* Extra scrollbar protection */
  * {
    box-sizing: border-box;
  }
  
  ::-webkit-scrollbar {
    display: none;
  }
  
  body {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
</style>
</head>
<body>
<div class="container">
  <div class="heading">
    <h1>RectBlox</h1>
  </div>
  
  <div class="game-wrapper">
    <div class="score-panel">
      <div class="level-info">Level <span id="level">1</span>: <span id="levelName">Easy Level</span></div>
      <div class="score-box">Moves Left: <span id="moves">40</span></div>
      <div class="score-box" style="background: linear-gradient(135deg, #a8b47f 0%, #8e9c6e 100%);">Score: <span id="score">0</span></div>
      <button class="secondary-button" id="shuffleBtn">Shuffle Blocks (3 moves)</button>
      <button class="secondary-button" id="restartBtn">Restart Game</button>
    </div>
    
    <div class="game-container" id="game">
      <div class="grid-container" id="grid"></div>
      <div class="tile-container" id="tiles"></div>
      <div class="overlay" id="overlay">
        <div class="text" id="overlayText"></div>
        <div class="score-summary" id="scoreSummary" style="display: none;"></div>
        <div class="instructions" id="instructions" style="display: none;">
          <div style="margin-bottom: 0.8rem; font-size: 1rem; color: #d4a574; font-weight: bold;">How to Play</div>
          <div style="margin-bottom: 0.6rem;">üíª Computer: Arrow keys ‚¨ÖÔ∏è ‚û°Ô∏è ‚¨ÜÔ∏è ‚¨áÔ∏è</div>
          <div style="margin-bottom: 1rem;">üì± Mobile: Swipe screen</div>
          <div style="font-size: 0.8rem; color: #8a6d5b; margin-bottom: 0.8rem;">Match same colors to remove blocks!</div>
          <div style="font-size: 0.75rem; color: #a8926f; font-style: italic; animation: pulse 2s infinite;">üëÜ Tap here or anywhere to start game</div>
        </div>
        <button id="overlayRestartBtn">Play Again</button>
        <button id="instructionsBtn" style="display: none;">Start Game</button>
      </div>
    </div>
  </div>
</div>
<script>
// Game level settings
const LEVELS = {
  1: { size: 5, colors: ['red', 'green', 'blue'], initialMoves: 40, name: 'Easy Level' },
  2: { size: 6, colors: ['red', 'green', 'blue', 'purple'], name: 'Medium Level' },
  3: { size: 7, colors: ['red', 'green', 'blue', 'purple', 'orange'], name: 'Hard Level' },
  4: { size: 8, colors: ['red', 'green', 'blue', 'purple', 'orange', 'pink'], name: 'Super Hard' }
};

let currentLevel = 1;
let SIZE = LEVELS[currentLevel].size;
let PROPS = LEVELS[currentLevel].colors;
let boardMatrix = [];
let boardElements = [];
let movesLeft = LEVELS[currentLevel].initialMoves; // Set initial moves only at start
let isAnimating = false;
let gameScore = 0;
let levelScores = []; // Record scores for each level
let totalBlocks = 0; // Track total blocks removed

const movesEl          = document.getElementById('moves');
const levelEl          = document.getElementById('level');
const levelNameEl      = document.getElementById('levelName');
const scoreEl          = document.getElementById('score');
const overlay          = document.getElementById('overlay');
const overlayText      = document.getElementById('overlayText');
const tileContainer    = document.getElementById('tiles');
const shuffleBtn       = document.getElementById('shuffleBtn');
const restartBtn       = document.getElementById('restartBtn');
const overlayRestartBtn= document.getElementById('overlayRestartBtn');
const instructionsDiv  = document.getElementById('instructions');
const instructionsBtn  = document.getElementById('instructionsBtn');

function initGrid() {
  // Background grid removed, no need to create
}

function createTile(x, y, color) {
  const tile = document.createElement('div');
  tile.className = `tile tile-${color} tile-new`;
  
  // Responsive size calculation - adjust based on current level size
  const gameContainer = document.querySelector('.game-container');
  const containerRect = gameContainer.getBoundingClientRect();
  const containerSize = Math.min(containerRect.width, containerRect.height) - 32; // Remove padding
  const tileSize = (containerSize - (SIZE-1) * 8) / SIZE; // Calculate dynamically based on SIZE
  const gap = 8;
  
  tile.style.width = `${tileSize}px`;
  tile.style.height = `${tileSize}px`;
  tile.style.lineHeight = `${tileSize}px`;
  tile.style.fontSize = `${Math.min(tileSize * 0.6, 28)}px`;
  tile.style.transform = `translate(${x * (tileSize + gap)}px, ${y * (tileSize + gap)}px)`;
  
  tileContainer.appendChild(tile);
  requestAnimationFrame(() => tile.classList.remove('tile-new'));
  return tile;
}

function updateGameSettings() {
  SIZE = LEVELS[currentLevel].size;
  PROPS = LEVELS[currentLevel].colors;
  // Don't reset moves, let them carry over to next level
}

function initBoard() {
  updateGameSettings();
  boardMatrix   = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
  boardElements = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
  tileContainer.innerHTML = '';
  isAnimating = false;
  hideOverlay(); 
  updateUI();
  
  const initial = Math.floor((SIZE*SIZE)/2);
  for (let i = 0; i < initial; i++) {
    let x, y;
    do { x = Math.floor(Math.random()*SIZE); y = Math.floor(Math.random()*SIZE); }
    while (boardMatrix[y][x] != null);
    const c = PROPS[Math.floor(Math.random()*PROPS.length)];
    boardMatrix[y][x] = c;
    boardElements[y][x] = createTile(x,y,c);
  }
}

function updateUI() {
  movesEl.textContent = movesLeft;
  levelEl.textContent = currentLevel;
  levelNameEl.textContent = LEVELS[currentLevel].name;
  scoreEl.textContent = gameScore;
}

function nextLevel() {
  // Record current level score
  const levelScore = calculateLevelScore();
  levelScores.push({
    level: currentLevel,
    score: levelScore,
    remainingMoves: movesLeft
  });
  
  if (currentLevel < Object.keys(LEVELS).length) {
    // Show short message, then go to next level
    showScoreMessage(`Level ${currentLevel} Done! Got ${levelScore} points`, 0);
    currentLevel++;
    
    // Wait a bit for player to see message, then go to next level
    setTimeout(() => {
      initBoard();
    }, 1500);
  } else {
    // Last level done, show final score
    showGameCompleteOverlay();
  }
}

function calculateLevelScore() {
  // Calculate score based on remaining moves and level difficulty
  const baseScore = 1000;
  const moveBonus = movesLeft * 50; // 50 points per remaining move
  const levelMultiplier = currentLevel; // Level multiplier
  return Math.floor((baseScore + moveBonus) * levelMultiplier);
}

function showGameCompleteOverlay() {
  // If current level score not recorded yet, record it first
  if (!levelScores.length || levelScores[levelScores.length - 1].level !== currentLevel) {
    const levelScore = calculateLevelScore();
    levelScores.push({
      level: currentLevel,
      score: levelScore,
      remainingMoves: movesLeft
    });
  }
  
  const totalScore = levelScores.reduce((sum, level) => sum + level.score, 0);
  const totalRemainingMoves = levelScores.reduce((sum, level) => sum + level.remainingMoves, 0);
  const scoreSummary = document.getElementById('scoreSummary');
  
  // Check if all levels completed
  const isAllLevelsComplete = currentLevel === Object.keys(LEVELS).length;
  const titleText = isAllLevelsComplete ? 'üéâ Game Complete! üéâ' : 'üìä No More Moves! üìä';
  
  let summaryHTML = `<h3 style="margin: 0 0 1rem 0; color: #d4a574;">${titleText}</h3>`;
  
  levelScores.forEach(level => {
    summaryHTML += `
      <div class="score-item">
        <span>Level ${level.level}</span>
        <span>${level.score.toLocaleString()} points</span>
      </div>
    `;
  });
  
  summaryHTML += `
    <div class="score-item">
      <span>Total Blocks Removed</span>
      <span>${totalBlocks}</span>
    </div>
    <div class="score-item">
      <span>Total Moves Saved</span>
      <span>${totalRemainingMoves}</span>
    </div>
    <div class="score-item">
      <span>Final Score</span>
      <span>${totalScore.toLocaleString()} points</span>
    </div>
  `;
  
  // Add click instruction at the bottom
  summaryHTML += `<div style="margin-top: 1rem; font-size: 0.8rem; color: #a8926f; text-align: center; font-style: italic;">üëÜ Tap anywhere to restart game</div>`;
  
  scoreSummary.innerHTML = summaryHTML;
  scoreSummary.style.display = 'block';
  
  const overlayMessage = isAllLevelsComplete ? 'All Levels Complete!' : 'No More Moves!';
  showOverlay(overlayMessage);
  
  // Add event listeners for clicking anywhere to restart
  overlay.addEventListener('click', restartFromGameComplete);
  overlay.addEventListener('touchend', restartFromGameCompleteTouch);
}

function restartFromGameComplete(e) {
  // Prevent event bubbling to score summary
  if (e.target === document.getElementById('scoreSummary') || document.getElementById('scoreSummary').contains(e.target)) {
    return;
  }
  overlay.removeEventListener('click', restartFromGameComplete);
  overlay.removeEventListener('touchend', restartFromGameCompleteTouch);
  restartGame();
}

function restartFromGameCompleteTouch(e) {
  e.preventDefault();
  e.stopPropagation();
  // Prevent event bubbling to score summary
  if (e.target === document.getElementById('scoreSummary') || document.getElementById('scoreSummary').contains(e.target)) {
    return;
  }
  overlay.removeEventListener('click', restartFromGameComplete);
  overlay.removeEventListener('touchend', restartFromGameCompleteTouch);
  restartGame();
}

function restartGame() {
  currentLevel = 1;
  movesLeft = LEVELS[1].initialMoves;
  gameScore = 0;
  levelScores = [];
  totalBlocks = 0;
  document.getElementById('scoreSummary').style.display = 'none';
  initBoard();
  setTimeout(() => showInstructions(), 500);
}

// Add event listeners for score summary click
document.getElementById('scoreSummary').addEventListener('click', function(e) {
  e.stopPropagation();
  // Click on score summary also restarts game
  overlay.removeEventListener('click', restartFromGameComplete);
  overlay.removeEventListener('touchend', restartFromGameCompleteTouch);
  restartGame();
});

document.getElementById('scoreSummary').addEventListener('touchend', function(e) {
  e.preventDefault();
  e.stopPropagation();
  // Touch on score summary also restarts game
  overlay.removeEventListener('click', restartFromGameComplete);
  overlay.removeEventListener('touchend', restartFromGameCompleteTouch);
  restartGame();
});

function showOverlay(msg) { 
  overlayText.textContent = msg; 
  overlay.classList.add('show'); 
}

function hideOverlay() { 
  overlay.classList.remove('show');
  // Reset overlay elements
  instructionsDiv.style.display = 'none';
  overlayRestartBtn.style.display = 'inline-block';
  instructionsBtn.style.display = 'none';
  
  // Clean up event listeners
  overlay.removeEventListener('click', startGameFromInstructions);
  overlay.removeEventListener('touchend', startGameFromInstructionsTouch);
  overlay.removeEventListener('click', restartFromGameComplete);
  overlay.removeEventListener('touchend', restartFromGameCompleteTouch);
}

function showInstructions() {
  overlayText.textContent = '';
  instructionsDiv.style.display = 'block';
  overlayRestartBtn.style.display = 'none';
  instructionsBtn.style.display = 'none';
  overlay.classList.add('show');
  
  // ÈªûÊìäoverlay‰ªª‰ΩïÂú∞ÊñπÈÉΩÂèØ‰ª•ÈñãÂßãÈÅäÊà≤ - ÂêåÊôÇÊîØÊè¥ÊªëÈº†ÂíåËß∏Êéß
  overlay.addEventListener('click', startGameFromInstructions);
  overlay.addEventListener('touchend', startGameFromInstructionsTouch);
}

function startGameFromInstructions(e) {
  // Èò≤Ê≠¢‰∫ã‰ª∂ÂÜíÊ≥°Âà∞instructions div
  if (e.target === instructionsDiv || instructionsDiv.contains(e.target)) {
    return;
  }
  overlay.removeEventListener('click', startGameFromInstructions);
  overlay.removeEventListener('touchend', startGameFromInstructionsTouch);
  hideOverlay();
}

function startGameFromInstructionsTouch(e) {
  e.preventDefault();
  e.stopPropagation();
  // Èò≤Ê≠¢‰∫ã‰ª∂ÂÜíÊ≥°Âà∞instructions div
  if (e.target === instructionsDiv || instructionsDiv.contains(e.target)) {
    return;
  }
  overlay.removeEventListener('click', startGameFromInstructions);
  overlay.removeEventListener('touchend', startGameFromInstructionsTouch);
  hideOverlay();
}

shuffleBtn.addEventListener('click', ()=>{
  if (isAnimating || movesLeft < 3) return alert('Not enough moves! Need at least 3 moves to shuffle blocks');
  movesLeft -= 3; 
  updateUI(); 
  shuffleTiles();
});

restartBtn.addEventListener('click', () => {
  restartGame();
});

overlayRestartBtn.addEventListener('click', () => {
  restartGame();
});

// Add touch support for mobile
overlayRestartBtn.addEventListener('touchend', function(e) {
  e.preventDefault();
  e.stopPropagation();
  restartGame();
});

shuffleBtn.addEventListener('touchend', function(e) {
  e.preventDefault();
  e.stopPropagation();
  if (isAnimating || movesLeft < 3) return alert('Not enough moves! Need at least 3 moves to shuffle blocks');
  movesLeft -= 3; 
  updateUI(); 
  shuffleTiles();
});

restartBtn.addEventListener('touchend', function(e) {
  e.preventDefault();
  e.stopPropagation();
  restartGame();
});

function shuffleTiles() {
  // Collect all current tiles
  const allTiles = [];
  boardMatrix.forEach(row => {
    row.forEach(cell => {
      if (cell) allTiles.push(cell);
    });
  });
  
  // Clear the board
  tileContainer.innerHTML = '';
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      boardMatrix[y][x] = null;
      boardElements[y][x] = null;
    }
  }
  
  // Get all possible positions
  const allPositions = [];
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      allPositions.push({x, y});
    }
  }
  
  // Randomly shuffle positions
  for (let i = allPositions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
  }
  
  // Place tiles in new random positions
  allTiles.forEach((color, index) => {
    const {x, y} = allPositions[index];
    boardMatrix[y][x] = color;
    boardElements[y][x] = createTile(x, y, color);
  });
}

// Handle move directions
function handleMove(direction) {
  let dir = null;
  switch(direction) {
    case 0: dir = {x:0,y:-1,axis:'y'}; break;  // Up
    case 1: dir = {x:1,y:0, axis:'x'}; break;  // Right
    case 2: dir = {x:0,y:1, axis:'y'}; break;  // Down
    case 3: dir = {x:-1,y:0,axis:'x'}; break;  // Left
  }
  if (!dir || isAnimating) return;
  
  // If moves are 0, trigger game summary
  if (movesLeft <= 0) {
    isAnimating = true;
    setTimeout(() => {
      // Record current level score if not recorded yet
      if (!levelScores.length || levelScores[levelScores.length - 1].level !== currentLevel) {
        const levelScore = calculateLevelScore();
        levelScores.push({
          level: currentLevel,
          score: levelScore,
          remainingMoves: movesLeft
        });
      }
      // Áõ¥Êé•È°ØÁ§∫ÁµêÁÆóË°®
      showGameCompleteOverlay();
    }, 500);
    return;
  }
  
  movesLeft--; 
  updateUI();
  
  // Ê™¢Êü•Ê≠•Êï∏ÊòØÂê¶ËÄóÁõ°
  if (movesLeft === 0) { 
    isAnimating = true; // Èò≤Ê≠¢ÈáçË§áËß∏Áôº
    setTimeout(() => {
      // Ë®òÈåÑÁï∂ÂâçÈóúÂç°ÂàÜÊï∏
      const levelScore = calculateLevelScore();
      levelScores.push({
        level: currentLevel,
        score: levelScore,
        remainingMoves: movesLeft
      });
      
      // Áõ¥Êé•È°ØÁ§∫ÁµêÁÆóË°®Ôºå‰∏çË´ñÊòØÂê¶ÂÆåÊàêÊâÄÊúâÈóúÂç°
      showGameCompleteOverlay();
    }, 500); // Á®çÂæÆÂª∂ÈÅ≤ËÆìÁé©ÂÆ∂ÁúãÂà∞ÁßªÂãïÊïàÊûú
    return; 
  }
  
  isAnimating = true;
  cascade(dir);
}

// ÈçµÁõ§‰∫ã‰ª∂ËôïÁêÜ
document.addEventListener('keydown', e => {
  let direction = null;
  if (e.key==='ArrowUp')    direction = 0;
  if (e.key==='ArrowDown')  direction = 2;
  if (e.key==='ArrowLeft')  direction = 3;
  if (e.key==='ArrowRight') direction = 1;
  if (direction !== null) handleMove(direction);
});

// Ëß∏ÊéßÊªëÂãïÊîØÊè¥
let touchStartX, touchStartY;
const gameContainer = document.getElementById('game');

// Ëß∏ÊéßÈñãÂßã‰∫ã‰ª∂
gameContainer.addEventListener('touchstart', e => {
  // Â¶ÇÊûúÈªûÊìäÁöÑÊòØÊåâÈàïÔºåÂ∞±‰∏çËôïÁêÜÊªëÂãï
  if (e.target.tagName === 'BUTTON') return;
  
  if (e.touches.length > 1) return; // ÂøΩÁï•Â§öÊåáËß∏Êéß
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  e.preventDefault();
});

// Ëß∏ÊéßÁßªÂãï‰∫ã‰ª∂ÔºàÈò≤Ê≠¢È†ÅÈù¢ÊªæÂãïÔºâ
gameContainer.addEventListener('touchmove', e => {
  // Â¶ÇÊûúÈªûÊìäÁöÑÊòØÊåâÈàïÔºåÂ∞±‰∏çÈòªÊ≠¢ÈªòË™çË°åÁÇ∫
  if (e.target.tagName === 'BUTTON') return;
  e.preventDefault();
});

// Èò≤Ê≠¢Êï¥ÂÄãÊñáÊ™îÊªæÂãï
document.addEventListener('touchmove', e => {
  e.preventDefault();
}, { passive: false });

// Èò≤Ê≠¢ÊªæËº™ÊªæÂãï
document.addEventListener('wheel', e => {
  e.preventDefault();
}, { passive: false });

// Ëß∏ÊéßÁµêÊùü‰∫ã‰ª∂
gameContainer.addEventListener('touchend', e => {
  // Â¶ÇÊûúÈªûÊìäÁöÑÊòØÊåâÈàïÔºåÂ∞±‰∏çËôïÁêÜÊªëÂãï
  if (e.target.tagName === 'BUTTON') return;
  
  if (e.touches.length > 0) return; // Â¶ÇÊûúÈÇÑÊúâÊâãÊåáÂú®Ëû¢Âπï‰∏äÂ∞±ÂøΩÁï•
  
  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  
  // ÊªëÂãïË∑ùÈõ¢ÂøÖÈ†àÂ§ßÊñº 30 ÂÉèÁ¥†ÊâçÁÆóÊúâÊïàÊªëÂãï
  if (Math.max(absDx, absDy) > 30) {
    let direction;
    if (absDx > absDy) {
      // Ê∞¥Âπ≥ÊªëÂãï
      direction = dx > 0 ? 1 : 3; // Âè≥:1, Â∑¶:3
    } else {
      // ÂûÇÁõ¥ÊªëÂãï
      direction = dy > 0 ? 2 : 0; // ‰∏ã:2, ‰∏ä:0
    }
    handleMove(direction);
  }
});

function cascade(dir) {
  compress(dir);
  setTimeout(() => {
    const matches = findMatches();
    if (matches.length === 0) { 
      // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅËá™ÂãïÁîüÊàêÊñπÂ°ä
      checkAndGenerateLonelyTiles();
      isAnimating = false; 
      return; 
    }
    
    // È°ØÁ§∫ÈÄ£ÈéñÊèêÁ§∫
    if (matches.length >= 3) {
      let comboText = 'NICE!';
      if (matches.length >= 5) comboText = 'COMBO!';
      if (matches.length >= 8) comboText = 'AMAZING!';
      showComboMessage(comboText);
    }
    
    removeMatches(matches, () => {
      if (boardMatrix.flat().every(v => !v)) {
        // Áõ§Èù¢Ê∏ÖÁ©∫ÔºåÊ™¢Êü•ÊòØÂê¶ÈÇÑÊúâ‰∏ã‰∏ÄÈóú
        if (currentLevel < Object.keys(LEVELS).length) {
          nextLevel(); // Ê≠£Â∏∏ÈÅéÈóúÔºå‰ΩøÁî®nextLevel
        } else {
          // ÊâÄÊúâÈóúÂç°ÂÆåÊàê‰∏îÁõ§Èù¢Ê∏ÖÁ©∫ÔºåÈ°ØÁ§∫ÁµêÁÆóË°®
          showGameCompleteOverlay();
        }
      } else {
        setTimeout(() => cascade(dir), 200); // Á®çÂæÆÂª∂Èï∑ËÆìÁé©ÂÆ∂ÁúãÂà∞ÊïàÊûú
      }
    });
  }, 160);
}

function compress(dir) {
  const gameContainer = document.querySelector('.game-container');
  const containerRect = gameContainer.getBoundingClientRect();
  const containerSize = Math.min(containerRect.width, containerRect.height) - 32;
  const tileSize = (containerSize - (SIZE-1) * 8) / SIZE; // Ê†πÊìöSIZEÂãïÊÖãË®àÁÆó
  const gap = 8;
  
  if (dir.axis==='x') {
    for (let y=0; y<SIZE; y++) {
      const elems = boardElements[y].filter(e=>e);
      const vals  = boardMatrix[y].filter(v=>v);
      const pad   = Array(SIZE-elems.length).fill(null);
      boardElements[y] = dir.x>0 ? [...pad,...elems] : [...elems,...pad];
      boardMatrix[y]   = dir.x>0 ? [...pad,...vals]  : [...vals,...pad];
      boardElements[y].forEach((t,i)=>{
        if(t) {
          const x = i * (tileSize + gap);
          const y_pos = y * (tileSize + gap);
          t.style.transform = `translate(${x}px, ${y_pos}px)`;
          t.style.width = `${tileSize}px`;
          t.style.height = `${tileSize}px`;
          t.style.lineHeight = `${tileSize}px`;
          t.style.fontSize = `${Math.min(tileSize * 0.6, 28)}px`;
        }
      });
    }
  } else {
    for (let x=0; x<SIZE; x++) {
      const elems=[], vals=[];
      for (let y=0; y<SIZE; y++) if(boardElements[y][x]){ elems.push(boardElements[y][x]); vals.push(boardMatrix[y][x]); }
      const pad = Array(SIZE-elems.length).fill(null);
      const newEls = dir.y>0 ? [...pad,...elems] : [...elems,...pad];
      const newVals= dir.y>0 ? [...pad,...vals]  : [...vals,...pad];
      for (let y=0; y<SIZE; y++) {
        boardElements[y][x]=newEls[y]; boardMatrix[y][x]=newVals[y];
        if (newEls[y]) {
          const x_pos = x * (tileSize + gap);
          const y_pos = y * (tileSize + gap);
          newEls[y].style.transform = `translate(${x_pos}px, ${y_pos}px)`;
          newEls[y].style.width = `${tileSize}px`;
          newEls[y].style.height = `${tileSize}px`;
          newEls[y].style.lineHeight = `${tileSize}px`;
          newEls[y].style.fontSize = `${Math.min(tileSize * 0.6, 28)}px`;
        }
      }
    }
  }
}

function findMatches() {
  const m = [];
  for (let y=0; y<SIZE; y++) for (let x=0; x<SIZE; x++) {
    const c=boardMatrix[y][x]; if(!c) continue;
    if (x<SIZE-1 && boardMatrix[y][x+1]===c) m.push([x,y],[x+1,y]);
    if (y<SIZE-1 && boardMatrix[y+1][x]===c) m.push([x,y],[x,y+1]);
  }
  return m.filter((v,i,a)=>a.findIndex(w=>w[0]===v[0]&&w[1]===v[1])===i);
}

function removeMatches(ms, cb) {
  // Calculate score
  const blockScore = ms.length * 10 * currentLevel; // 10 points per block, times level multiplier
  gameScore += blockScore;
  totalBlocks += ms.length;
  updateUI();
  
  // Show score increase message
  if (ms.length > 0) {
    showScoreMessage(`+${blockScore} points`, ms.length);
  }
  
  // Show combo message
  if (ms.length >= 3) {
    let comboText = 'NICE!';
    if (ms.length >= 5) comboText = 'COMBO!';
    if (ms.length >= 8) comboText = 'AMAZING!';
    showComboMessage(comboText);
  }
  
  ms.forEach(([x,y],i) => setTimeout(() => {
    const t = boardElements[y][x];
    if (!t) return;
    
    // Mobile simplified effects - only show full effects for single or small removals
    const isMobile = window.innerWidth <= 768;
    const shouldShowFullEffect = !isMobile || ms.length <= 4;
    
    if (shouldShowFullEffect) {
      // Create flash effect
      createFlashEffect(t, x, y);
      
      // Create particle explosion
      createParticleExplosion(t, x, y);
    }
    
    // Add vibration (small range only)
    if (shouldShowFullEffect && navigator.vibrate) {
      navigator.vibrate(30);
    }
    
    boardElements[y][x] = null;
    boardMatrix[y][x] = null;
    t.classList.add('tile-remove');
    
    // Remove element
    setTimeout(() => {
      if (t.parentNode) t.parentNode.removeChild(t);
    }, 400);
    
  }, i * 60)); // Speed up removal
  
  setTimeout(cb, ms.length * 60 + 400);
}

// Show score increase message
function showScoreMessage(text, blockCount) {
  const message = document.createElement('div');
  message.textContent = text;
  message.style.position = 'absolute';
  message.style.left = '50%';
  message.style.top = '40%';
  message.style.transform = 'translate(-50%, -50%)';
  message.style.fontSize = '1.5rem';
  message.style.fontWeight = 'bold';
  message.style.color = '#d4a574';
  message.style.background = 'rgba(255, 255, 255, 0.9)';
  message.style.padding = '0.5rem 1rem';
  message.style.borderRadius = '12px';
  message.style.textShadow = '1px 1px 2px rgba(0,0,0,0.1)';
  message.style.boxShadow = '0 4px 12px rgba(212, 165, 116, 0.3)';
  message.style.zIndex = '16';
  message.style.pointerEvents = 'none';
  message.style.animation = 'combo-fade 1.5s ease-out forwards';
  
  document.querySelector('.game-container').appendChild(message);
  
  setTimeout(() => {
    if (message.parentNode) message.parentNode.removeChild(message);
  }, 1500);
}

// Show combo message text
function showComboMessage(text) {
  const message = document.createElement('div');
  message.textContent = text;
  message.style.position = 'absolute';
  message.style.left = '50%';
  message.style.top = '50%';
  message.style.transform = 'translate(-50%, -50%)';
  message.style.fontSize = '2rem';
  message.style.fontWeight = 'bold';
  message.style.color = '#6b4e3d';
  message.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
  message.style.zIndex = '15';
  message.style.pointerEvents = 'none';
  message.style.animation = 'combo-fade 1.5s ease-out forwards';
  
  document.querySelector('.game-container').appendChild(message);
  
  setTimeout(() => {
    if (message.parentNode) message.parentNode.removeChild(message);
  }, 1500);
}

// Create flash effect - performance optimized
function createFlashEffect(tile, x, y) {
  const gameContainer = document.querySelector('.game-container');
  const containerRect = gameContainer.getBoundingClientRect();
  const containerSize = Math.min(containerRect.width, containerRect.height) - 32;
  const tileSize = (containerSize - (SIZE-1) * 8) / SIZE; // Ê†πÊìöSIZEÂãïÊÖãË®àÁÆó
  const gap = 8;
  
  const centerX = x * (tileSize + gap);
  const centerY = y * (tileSize + gap);
  
  // Simplified flash effect - remove complex style calculations
  const flashTile = document.createElement('div');
  flashTile.className = tile.className.replace('tile-new', '').replace('tile-remove', '');
  flashTile.style.position = 'absolute';
  flashTile.style.left = centerX + 'px';
  flashTile.style.top = centerY + 'px';
  flashTile.style.width = tileSize + 'px';
  flashTile.style.height = tileSize + 'px';
  flashTile.style.borderRadius = '12px';
  flashTile.style.animation = 'tile-pulse 500ms ease-out 1'; // Shorter animation
  flashTile.style.zIndex = '20';
  flashTile.style.pointerEvents = 'none';
  
  document.querySelector('.tile-container').appendChild(flashTile);
  
  setTimeout(() => {
    if (flashTile.parentNode) flashTile.parentNode.removeChild(flashTile);
  }, 500);
}

// Create particle explosion - performance optimized
function createParticleExplosion(tile, x, y) {
  const isMobile = window.innerWidth <= 768;
  const gameContainer = document.querySelector('.game-container');
  let centerX, centerY, tileSize;
  
  if (isMobile) {
    const containerWidth = gameContainer.offsetWidth;
    tileSize = (containerWidth * 0.94 - containerWidth * 0.02 * (SIZE-1)) / SIZE; // Calculate dynamically based on SIZE
    const gap = containerWidth * 0.02;
    
    const tileContainer = document.querySelector('.tile-container');
    const containerRect = gameContainer.getBoundingClientRect();
    const tileContainerRect = tileContainer.getBoundingClientRect();
    
    const offsetX = tileContainerRect.left - containerRect.left;
    const offsetY = tileContainerRect.top - containerRect.top;
    
    centerX = offsetX + x * (tileSize + gap) + tileSize / 2;
    centerY = offsetY + y * (tileSize + gap) + tileSize / 2;
  } else {
    // Desktop version - calculate dynamically based on SIZE
    const gameContainer = document.querySelector('.game-container');
    const containerRect = gameContainer.getBoundingClientRect();
    const containerSize = Math.min(containerRect.width, containerRect.height) - 32;
    tileSize = (containerSize - (SIZE-1) * 8) / SIZE;
    const gap = 8;
    centerX = 15 + x * (tileSize + gap) + tileSize / 2;
    centerY = 15 + y * (tileSize + gap) + tileSize / 2;
  }
  
  // Get tile color
  const computedStyle = window.getComputedStyle(tile);
  const bgColor = computedStyle.backgroundColor;
  
  // Reduce particle count - mobile 6, desktop 8
  const particleCount = isMobile ? 6 : 8;
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.background = bgColor;
    particle.style.left = centerX + 'px';
    particle.style.top = centerY + 'px';
    
    // Random direction and distance - smaller range
    const angle = (i / particleCount) * Math.PI * 2;
    const distance = 50 + Math.random() * 30; // Smaller explosion range
    const dx = Math.cos(angle) * distance + 'px';
    const dy = Math.sin(angle) * distance + 'px';
    
    particle.style.setProperty('--dx', dx);
    particle.style.setProperty('--dy', dy);
    
    gameContainer.appendChild(particle);
    
    // Remove particles early
    setTimeout(() => {
      if (particle.parentNode) particle.parentNode.removeChild(particle);
    }, 400);
  }
  
  // Simplified ripple effect - remove complex styles
  const ripple = document.createElement('div');
  ripple.style.position = 'absolute';
  ripple.style.left = (centerX - tileSize/2) + 'px';
  ripple.style.top = (centerY - tileSize/2) + 'px';
  ripple.style.width = tileSize + 'px';
  ripple.style.height = tileSize + 'px';
  ripple.style.borderRadius = '50%';
  ripple.style.background = `radial-gradient(circle, ${bgColor}30 0%, transparent 70%)`;
  ripple.style.animation = 'ripple-effect 300ms ease-out forwards'; // Shorter time
  ripple.style.pointerEvents = 'none';
  ripple.style.zIndex = '12';
  
  gameContainer.appendChild(ripple);
  
  setTimeout(() => {
    if (ripple.parentNode) ripple.parentNode.removeChild(ripple);
  }, 300);
}

// Check lonely tiles and auto-generate
function checkAndGenerateLonelyTiles() {
  // Count each color
  const colorCounts = {};
  PROPS.forEach(color => colorCounts[color] = 0);
  
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const color = boardMatrix[y][x];
      if (color) {
        colorCounts[color]++;
      }
    }
  }
  
  // Find colors with only one tile
  const lonelyColors = [];
  Object.keys(colorCounts).forEach(color => {
    if (colorCounts[color] === 1) {
      lonelyColors.push(color);
    }
  });
  
  // Generate new tile for each lonely color
  lonelyColors.forEach(color => {
    generateTileForColor(color);
  });
}

// Generate new tile for specific color
function generateTileForColor(color) {
  // Check if moves remaining
  if (movesLeft <= 0) return;
  
  // Find all empty positions
  const emptyPositions = [];
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (boardMatrix[y][x] === null) {
        emptyPositions.push({x, y});
      }
    }
  }
  
  // Don't generate if no empty positions
  if (emptyPositions.length === 0) return;
  
  // Randomly choose an empty position
  const randomIndex = Math.floor(Math.random() * emptyPositions.length);
  const position = emptyPositions[randomIndex];
  
  // Generate new tile
  boardMatrix[position.y][position.x] = color;
  boardElements[position.y][position.x] = createTile(position.x, position.y, color);
  
  // Use one move
  movesLeft--;
  updateUI();
  
  // Show message
  showAutoGenerateMessage(color);
  
  // Check if moves finished
  if (movesLeft === 0) {
    setTimeout(() => {
      // Record current level score if not recorded yet
      if (!levelScores.length || levelScores[levelScores.length - 1].level !== currentLevel) {
        const levelScore = calculateLevelScore();
        levelScores.push({
          level: currentLevel,
          score: levelScore,
          remainingMoves: movesLeft
        });
      }
      // Show game summary
      showGameCompleteOverlay();
    }, 1500); // Let player see generation effect before showing summary
  }
}

// Show auto-generate message
function showAutoGenerateMessage(color) {
  const colorNames = {
    'red': 'Red',
    'green': 'Green', 
    'blue': 'Blue',
    'purple': 'Purple',
    'orange': 'Yellow',
    'pink': 'Pink'
  };
  
  const message = document.createElement('div');
  message.textContent = `New ${colorNames[color]} Block Added (-1 move)`;
  message.style.position = 'absolute';
  message.style.left = '50%';
  message.style.top = '30%';
  message.style.transform = 'translate(-50%, -50%)';
  message.style.fontSize = '1.2rem';
  message.style.fontWeight = 'bold';
  message.style.color = '#6b4e3d';
  message.style.background = 'rgba(255, 255, 255, 0.9)';
  message.style.padding = '0.5rem 1rem';
  message.style.borderRadius = '12px';
  message.style.textShadow = '1px 1px 2px rgba(0,0,0,0.1)';
  message.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
  message.style.zIndex = '15';
  message.style.pointerEvents = 'none';
  message.style.animation = 'combo-fade 2s ease-out forwards';
  
  document.querySelector('.game-container').appendChild(message);
  
  setTimeout(() => {
    if (message.parentNode) message.parentNode.removeChild(message);
  }, 2000);
}

// Recalculate positions when window resizes
window.addEventListener('resize', () => {
  const gameContainer = document.querySelector('.game-container');
  const containerRect = gameContainer.getBoundingClientRect();
  const containerSize = Math.min(containerRect.width, containerRect.height) - 32;
  const tileSize = (containerSize - (SIZE-1) * 8) / SIZE; // Calculate dynamically based on SIZE
  const gap = 8;
  
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      const tile = boardElements[y][x];
      if (tile) {
        const x_pos = x * (tileSize + gap);
        const y_pos = y * (tileSize + gap);
        tile.style.transform = `translate(${x_pos}px, ${y_pos}px)`;
        tile.style.width = `${tileSize}px`;
        tile.style.height = `${tileSize}px`;
        tile.style.lineHeight = `${tileSize}px`;
        tile.style.fontSize = `${Math.min(tileSize * 0.6, 28)}px`;
      }
    }
  }
});

// Instructions button event listener
instructionsBtn.addEventListener('click', () => {
  hideOverlay();
});

instructionsBtn.addEventListener('touchend', function(e) {
  e.preventDefault();
  e.stopPropagation();
  hideOverlay();
});

// Ê∑ªÂä†Ëß∏ÊéßÊîØÊè¥Áµ¶ÊåáÁ§∫Áï´Èù¢
instructionsDiv.addEventListener('click', function(e) {
  e.stopPropagation();
  // Âú®ÊâãÊ©ü‰∏äÈªûÊìäÊåáÁ§∫Ê°Ü‰πüËÉΩÈñãÂßãÈÅäÊà≤
  if (window.innerWidth <= 768) {
    overlay.removeEventListener('click', startGameFromInstructions);
    overlay.removeEventListener('touchend', startGameFromInstructionsTouch);
    hideOverlay();
  }
});

instructionsDiv.addEventListener('touchend', function(e) {
  e.preventDefault();
  e.stopPropagation();
  // Ëß∏ÊéßÊåáÁ§∫Ê°ÜÈñãÂßãÈÅäÊà≤
  overlay.removeEventListener('click', startGameFromInstructions);
  overlay.removeEventListener('touchend', startGameFromInstructionsTouch);
  hideOverlay();
});

initBoard();
// Show instructions when first loading the game
setTimeout(() => showInstructions(), 500);
</script>
</body>
</html>
